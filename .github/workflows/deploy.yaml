name: Deploy Snake Game to AWS

on:
  push:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: snake-game
  ECS_CLUSTER: snake-game-production-cluster
  ECS_SERVICE: snake-game-service
  ECS_TASK_FAMILY: snake-game-task
  TF_WORKING_DIR: terraform

jobs:
  terraform:
    name: Terraform Infrastructure
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.9.5  # ✅ 明确版本，防止 "terraform not found"

    - name: Verify Terraform Installation
      run: terraform version

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Init
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: terraform init

    - name: Terraform Validate
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: terraform validate

    - name: Terraform Apply
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: terraform apply -auto-approve -var="db_password=${{ secrets.DB_PASSWORD }}"

  deploy-app:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: terraform
    environment: production

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Get AWS Account ID
      id: account
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
        echo "Account ID: $ACCOUNT_ID"

    - name: Build Docker Image
      run: |
        cd src
        docker build -t ${{ env.ECR_REPOSITORY }}:${{ github.sha }} .

    - name: Push Docker Image to ECR
      run: |
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        ECR_IMAGE="$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ github.sha }}"
        
        echo "Pushing to ECR: $ECR_IMAGE"
        docker tag ${{ env.ECR_REPOSITORY }}:${{ github.sha }} $ECR_IMAGE
        docker push $ECR_IMAGE
        
        echo "ECR_IMAGE=$ECR_IMAGE" >> $GITHUB_ENV

    - name: Get RDS Connection Info
      id: rds-info
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        RDS_ENDPOINT=$(terraform output -raw rds_endpoint)
        DB_USERNAME=$(terraform output -raw db_username)
        DB_NAME=$(terraform output -raw db_name)
        
        echo "RDS_ENDPOINT=$RDS_ENDPOINT" >> $GITHUB_ENV
        echo "DB_USERNAME=$DB_USERNAME" >> $GITHUB_ENV
        echo "DB_NAME=$DB_NAME" >> $GITHUB_ENV

    - name: Get ECS Task Execution Role
      id: ecs-role
      run: |
        TASK_EXEC_ROLE_ARN=$(aws iam list-roles --query "Roles[?contains(RoleName, 'ecsTaskExecutionRole')].Arn" --output text | head -1)
        if [ -z "$TASK_EXEC_ROLE_ARN" ]; then
          TASK_EXEC_ROLE_ARN="arn:aws:iam::${{ env.ACCOUNT_ID }}:role/ecsTaskExecutionRole"
        fi
        echo "TASK_EXEC_ROLE_ARN=$TASK_EXEC_ROLE_ARN" >> $GITHUB_ENV
        echo "Using ECS task execution role: $TASK_EXEC_ROLE_ARN"

    - name: Create Task Definition JSON
      run: |
        DATABASE_URL="postgresql://${{ env.DB_USERNAME }}:${{ secrets.DB_PASSWORD }}@${{ env.RDS_ENDPOINT }}/${{ env.DB_NAME }}"
        cat > task-definition.json << EOF
        {
          "family": "${{ env.ECS_TASK_FAMILY }}",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "${{ env.TASK_EXEC_ROLE_ARN }}",
          "containerDefinitions": [
            {
              "name": "snake-game",
              "image": "${{ env.ECR_IMAGE }}",
              "essential": true,
              "portMappings": [
                { "containerPort": 5000, "hostPort": 5000, "protocol": "tcp" }
              ],
              "environment": [
                { "name": "DATABASE_URL", "value": "$DATABASE_URL" },
                { "name": "ENVIRONMENT", "value": "production" },
                { "name": "AWS_REGION", "value": "${{ env.AWS_REGION }}" }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ env.ECS_CLUSTER }}",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        echo "✅ Task definition created successfully."
        cat task-definition.json

    - name: Register ECS Task Definition
      run: aws ecs register-task-definition --cli-input-json file://task-definition.json

    - name: Update ECS Service
      run: |
        aws ecs update-service \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service ${{ env.ECS_SERVICE }} \
          --task-definition ${{ env.ECS_TASK_FAMILY }} \
          --force-new-deployment

    - name: Wait for ECS Deployment to Stabilize
      run: |
        echo "⏳ Waiting for ECS service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }}
        echo "✅ ECS service is stable."

    - name: Health Check
      run: |
        LOAD_BALANCER_DNS=$(aws elbv2 describe-load-balancers \
          --query 'LoadBalancers[?LoadBalancerName==`snake-game-production-alb`].DNSName' \
          --output text)
        echo "Application URL: http://$LOAD_BALANCER_DNS"
        
        echo "Running health checks..."
        for i in {1..15}; do
          if curl -fs http://$LOAD_BALANCER_DNS/health >/dev/null; then
            echo "✅ Health check passed!"
            break
          else
            echo "⏳ Attempt $i failed, retrying in 10s..."
            sleep 10
          fi
        done

    - name: Deployment Summary
      run: |
        LOAD_BALANCER_DNS=$(aws elbv2 describe-load-balancers \
          --query 'LoadBalancers[?LoadBalancerName==`snake-game-production-alb`].DNSName' \
          --output text)
        
        echo "🎉 Deployment Completed Successfully!"
        echo "========================================"
        echo "🌐 Application URL: http://$LOAD_BALANCER_DNS"
        echo "🛠️  Health Check: http://$LOAD_BALANCER_DNS/health"
        echo "🐳 ECR Image: ${{ env.ECR_IMAGE }}"
        echo "⚓ ECS Cluster: ${{ env.ECS_CLUSTER }}"
        echo "🔧 ECS Service: ${{ env.ECS_SERVICE }}"
